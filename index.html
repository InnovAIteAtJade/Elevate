<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Coming Soon</title>

<style>
body {
  margin:0;
  background:black;
  overflow:hidden;
  font-family:"Courier New", monospace;
}

/* COUNTDOWN */
#countdown-container {
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);
  text-align:center;
  z-index:50;
  color:white;
}
#countdown-label { font-size:2rem; margin-bottom:0.3rem; }
#countdown {
  font-size:3rem;
  font-weight:bold;
  color:white;
  text-shadow:0 0 10px #00ff00, 0 0 20px #00ff00;
}

/* REACTOR */
#reactor-fill {
  position:absolute;
  top:50%;
  left:50%;
  width:80vw;
  height:80vw;
  max-width:420px;
  max-height:420px;
  transform:translate(-50%, -50%);
  z-index:6;
  border-radius:50%;
  overflow:hidden;
}

/* PANELS */
.side-panel {
  position:absolute;
  top:50%;
  width:280px;
  padding:20px;
  background:rgba(0,0,0,0.3);
  border:2px solid #00ffbf;
  backdrop-filter:blur(4px);
  transform:translateY(-50%);
  box-shadow:0 0 22px rgba(0,255,180,0.25);
  z-index:3;
  transition:all 2s ease-in;
}

#left-panel { left:40px; border-color:#FFB700; }
#right-panel { right:40px; border-color:#1B5287; }

.panel-title {
  color:#00ffe0;
  margin-bottom:10px;
}
.panel-log {
  height:180px;
  overflow:hidden;
  opacity:0.85;
  color:#00ffb5;
}

/* SCANLINES */
.scanlines {
  position:fixed;
  top:0; left:0; right:0; bottom:0;
  pointer-events:none;
  background:repeating-linear-gradient(
    transparent 0px,
    transparent 2px,
    rgba(0,255,170,0.03) 3px
  );
  z-index:999;
}

/* MATRIX */
#matrix-canvas {
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  z-index:1000;
  pointer-events:none;
}

/* =========================================================
   MOBILE — COMPLETE RESTRUCTURE (STACK EVERYTHING)
   ========================================================= */
@media (max-width: 768px) {

  body {
    overflow:auto !important; /* allow vertical scrolling */
  }

  /* STACK LAYOUT — remove all absolute positioning */
  #countdown-container,
  #reactor-fill,
  #left-panel,
  #right-panel {
    position:relative !important;
    left:0 !important;
    right:0 !important;
    top:auto !important;
    transform:none !important;
  }

  /* ORDER ELEMENTS */
  body {
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:20px;
    padding-top:20px;
  }

  #countdown-container {
    margin-top:10px;
    text-align:center;
  }

  #countdown-label { font-size:6vw; }
  #countdown { font-size:9vw; }

  #reactor-fill {
    width:75vw;
    height:75vw;
    max-width:360px;
    max-height:360px;
    border-radius:50%;
  }

  .side-panel {
    width:90vw !important;
    max-width:380px;
    border-radius:8px;
    padding:15px;
  }

  .panel-title { font-size:5vw; text-align:center; }
  .panel-log { font-size:3.8vw; height:150px; }

}
</style>
</head>

<body>

<!-- TOP LOG PANEL (becomes top on mobile automatically) -->
<div id="left-panel" class="side-panel">
  <div class="panel-title">[NODE ALPHA]</div>
  <div class="panel-log" id="log1"></div>
</div>

<!-- REACTOR + COUNTDOWN -->
<canvas id="reactor-fill"></canvas>

<div id="countdown-container">
  <div id="countdown-label">Event starts in:</div>
  <div id="countdown">Loading...</div>
</div>

<!-- BOTTOM LOG PANEL -->
<div id="right-panel" class="side-panel">
  <div class="panel-title">[NODE OMEGA]</div>
  <div class="panel-log" id="log2"></div>
</div>

<canvas id="matrix-canvas"></canvas>
<div class="scanlines"></div>


<script>
/* ======= YOUR FULL JS (unchanged functionality) ======= */

const canvas=document.getElementById("reactor-fill");
const ctx=canvas.getContext("2d");

let cx=210, cy=210, radius=200;

function resizeCanvas(){
  const size = canvas.clientWidth;
  canvas.width = size;
  canvas.height = size;
  cx = size/2;
  cy = size/2;
  radius = size/2 - 10;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const fixedStartDate=new Date("2025-12-05T00:00:00");
const targetDate=new Date("2026-01-06T00:00:00");
const totalDuration=targetDate - fixedStartDate;

function cycleLogs(el, lines){
  let i=0;
  el._int = setInterval(()=>{
    el.innerHTML += "> "+lines[i]+"<br>";
    if(el.innerHTML.split("<br>").length>8)
      el.innerHTML = el.innerHTML.split("<br>").slice(1).join("<br>");
    i=(i+1)%lines.length;
  },1500);
}

const log1=document.getElementById("log1");
const log2=document.getElementById("log2");

cycleLogs(log1, [
  "Initializing node systems...",
  "Analyzing streams... telemetry stable",
  "Telemetry anomaly ↑",
  "Preparing core modules...",
  "Virtual sync in progress",
  "Analyzer spike ↑",
  "System nominal",
  "Check channel >"
]);

cycleLogs(log2, [
  "Monitoring sequence...",
  "Transmission stable",
  "Anomaly ↓ detected",
  "Packet analysis normal",
  "Virtual sync active",
  "Telemetry < detected",
  "Preparing modules",
  "Enter command sequence"
]);

/* EASING */
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

let countdownOver=false;
let draining=false;
let drainProgress=0;
let seq=[];
const konami=["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowRight","ArrowLeft","Enter"];

/* MATRIX */
let matrixActive=false;
const matrixCanvas=document.getElementById("matrix-canvas");
const mctx=matrixCanvas.getContext("2d");
matrixCanvas.width=window.innerWidth;
matrixCanvas.height=window.innerHeight;
const fontSize=18;
const columns=Math.floor(matrixCanvas.width/fontSize);
const drops=Array(columns).fill(1);

function drawMatrix(){
  if(!matrixActive) return;
  mctx.fillStyle="rgba(0,0,0,0.05)";
  mctx.fillRect(0,0,matrixCanvas.width,matrixCanvas.height);
  mctx.fillStyle="#0F0";
  mctx.font=fontSize+"px monospace";
  for(let i=0;i<columns;i++){
    const text=String.fromCharCode(33+Math.floor(Math.random()*94));
    mctx.fillText(text, i*fontSize, drops[i]*fontSize);
    if(drops[i]*fontSize > matrixCanvas.height && Math.random()>0.975) drops[i]=0;
    drops[i]++;
  }
  requestAnimationFrame(drawMatrix);
}

/* KONAMI */
window.addEventListener("keydown", e=>{
  seq.push(e.key);
  if(seq.length>konami.length) seq.shift();
  if(JSON.stringify(seq)===JSON.stringify(konami)){
    alert("Unauthorized Access: Restarting...");
    draining=true;
    drainProgress=0;
  }
});

/* WAVE */
let waveShift=0;

function originalDrawWave(percent){
  let eased = easeOutCubic(draining ? 1 - drainProgress : percent);
  const waves=[
    {amp:12,wl:110,sp:0.05},
    {amp:8, wl:80, sp:0.07},
    {amp:6, wl:60, sp:0.04},
    {amp:4, wl:30, sp:0.1}
  ];
  const halfH = canvas.height / 2;
  const fillH = halfH * eased;

  ctx.fillStyle = countdownOver ? "#FFD700" : "#1B5287";

  ctx.beginPath();
  for(let x=0;x<=canvas.width;x++){
    let y = canvas.height - fillH;
    waves.forEach(w=> y += Math.sin(x/w.wl + waveShift*w.sp)*w.amp );
    if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.lineTo(canvas.width,canvas.height);
  ctx.lineTo(0,canvas.height);
  ctx.fill();
}

function drawRings(){
  ctx.strokeStyle="rgba(255,255,255,0.05)";
  ctx.lineWidth=1;
  for(let r=20;r<=radius;r+=20){
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,2*Math.PI);
    ctx.stroke();
  }
}

function drawArc(percent){
  const startAngle=-Math.PI/2;
  const phaseTime=0.25;

  let phase=Math.min(Math.floor(percent/phaseTime),3);
  let localPercent=(percent-phase*phaseTime)/phaseTime;

  let blueEnd=0, goldStart=0, goldEnd=0;

  if(phase===0) blueEnd=localPercent;
  else if(phase===1){ blueEnd=1; goldStart=1; goldEnd=1-localPercent; }
  else if(phase===2){ goldEnd=1; blueEnd=localPercent; }
  else if(phase===3){ blueEnd=1; goldStart=1; goldEnd=1-localPercent; }

  if(draining){
    blueEnd=0;
    goldStart=0;
    goldEnd=1 - drainProgress;
  }

  function arc(color,start,end){
    if(end<=0) return;
    ctx.beginPath();
    ctx.strokeStyle=color;
    ctx.shadowColor=color;
    ctx.shadowBlur=20;
    ctx.lineWidth=8;
    ctx.arc(cx,cy,radius,startAngle+start*2*Math.PI,startAngle+end*2*Math.PI);
    ctx.stroke();
  }

  arc("gold",goldEnd,goldStart);
  arc("blue",0,blueEnd);

  ctx.shadowBlur=0;
}

function drawElevate(){
  ctx.fillStyle="#fff";
  ctx.font="bold "+(canvas.width*0.15)+"px Courier New";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.shadowColor="#fff";
  ctx.shadowBlur=20;
  ctx.fillText("ELEVATE", cx, cy);
}

function draw(percent){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx,cy,radius,0,2*Math.PI);
  ctx.clip();

  waveShift+=0.06;

  originalDrawWave(percent);
  drawRings();
  drawArc(percent);

  if(percent>=1 && !draining) drawElevate();

  ctx.restore();
}

/* MAIN LOOP */
const countdownEl=document.getElementById("countdown");
const countdownContainer=document.getElementById("countdown-container");

function update(){
  const now=new Date();
  let diff=targetDate-now;

  let percent=0;

  if(diff<=0){
    percent=1;
    countdownOver=true;
  } else {
    percent=1 - Math.max(0, Math.min(1, diff/totalDuration));
  }

  if(draining){
    drainProgress+=0.003;
    percent=Math.max(0,1-drainProgress);

    if(drainProgress>=1 && !matrixActive){
      matrixActive=true;
      drawMatrix();

      setTimeout(()=>{
        document.body.style.transition="transform 2s ease-in";
        document.body.style.transform="translateY(-100vh)";
        setTimeout(()=>window.location.href="portal.html",2000);
      },500);
    }
  }

  draw(percent);

  if(!draining){
    if(diff>0){
      let s=Math.floor(diff/1000);
      let d=Math.floor(s/86400); s%=86400;
      let h=Math.floor(s/3600); s%=3600;
      let m=Math.floor(s/60); s%=60;
      countdownEl.textContent=`${d}d ${h}h ${m}m ${s}s`;
    }
  }

  requestAnimationFrame(update);
}

update();
</script>

</body>
</html>
