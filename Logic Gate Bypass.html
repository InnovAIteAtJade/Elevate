<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LOGIC BYPASS</title>
<style>
    body {
        margin: 0;
        background: #050505;
        color: #ffb700;
        font-family: "Courier New", monospace;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        overflow: hidden;
        user-select: none;
    }

    h2 {
        text-shadow: 0 0 10px #ffb700;
        margin-bottom: 10px;
        font-size: 1.2rem;
    }

    #timer-container {
        width: 320px;
        height: 15px;
        border: 2px solid #ff0000;
        margin-bottom: 10px;
        position: relative;
        background: #220000;
    }

    #timer-fill {
        height: 100%;
        width: 100%;
        background: #ff0000;
        transition: width 1s linear;
        box-shadow: 0 0 10px #ff0000;
    }

    #timer-text {
        position: absolute;
        top: -20px; left: 0; width: 100%;
        text-align: center;
        color: #ff0000;
        font-weight: bold;
        font-size: 0.9rem;
    }

    #game-container {
        display: flex;
        align-items: center;
        gap: 5px;
        position: relative;
    }

    .node {
        width: 40px;
        height: 40px;
        background: #222;
        border: 2px solid #555;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        z-index: 2;
        font-size: 0.7rem;
    }

    #source {
        border-color: #00ff00;
        color: #00ff00;
        box-shadow: 0 0 15px #00ff00;
        animation: pulse 1s infinite;
    }

    #output {
        border-color: #ff0000;
        color: #ff0000;
    }
    
    #output.powered {
        border-color: #00ff00;
        color: #00ff00;
        background: #003300;
        box-shadow: 0 0 20px #00ff00;
    }

    @keyframes pulse {
        0% { opacity: 0.6; }
        50% { opacity: 1; }
        100% { opacity: 0.6; }
    }

    #grid {
        display: grid;
        grid-template-columns: repeat(8, 40px);
        grid-template-rows: repeat(8, 40px);
        gap: 1px;
        background: #111;
        padding: 4px;
        border: 1px solid #333;
    }

    .tile {
        width: 40px;
        height: 40px;
        background: #1a1a1a;
        cursor: pointer;
        position: relative;
        transition: transform 0.1s;
    }

    .tile:hover {
        background: #252525;
    }

    /* SVG Styling within tiles */
    .pipe {
        width: 100%;
        height: 100%;
        fill: none;
        stroke: #444; /* Unpowered color */
        stroke-width: 10;
        stroke-linecap: square;
        transition: stroke 0.2s;
    }

    .tile.powered .pipe {
        stroke: #ffb700; /* Amber powered color */
        filter: drop-shadow(0 0 5px #ffb700);
    }

    #status-bar {
        margin-top: 10px;
        font-size: 0.9rem;
        text-align: center;
    }

    #modal {
        position: fixed;
        top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.95);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
    }

    #fail-modal {
        position: fixed;
        top:0; left:0; width:100%; height:100%;
        background: rgba(50,0,0,0.85);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        pointer-events: none;
    }

    .btn {
        margin-top: 20px;
        padding: 15px 30px;
        font-size: 1.2rem;
        background: #ffb700;
        color: black;
        border: none;
        cursor: pointer;
        font-weight: bold;
        border: 2px solid #ffb700;
    }
    .btn:hover {
        background: black;
        color: #ffb700;
    }

    @keyframes shake {
        0% { transform: translate(1px, 1px) rotate(0deg); }
        10% { transform: translate(-1px, -2px) rotate(-1deg); }
        20% { transform: translate(-3px, 0px) rotate(1deg); }
        30% { transform: translate(3px, 2px) rotate(0deg); }
        40% { transform: translate(1px, -1px) rotate(1deg); }
        50% { transform: translate(-1px, 2px) rotate(-1deg); }
        60% { transform: translate(-3px, 1px) rotate(0deg); }
        70% { transform: translate(3px, 1px) rotate(-1deg); }
        80% { transform: translate(-1px, -1px) rotate(1deg); }
        90% { transform: translate(1px, 2px) rotate(0deg); }
        100% { transform: translate(1px, -2px) rotate(-1deg); }
    }

    .shaking {
        animation: shake 0.5s;
        animation-iteration-count: infinite;
    }

</style>
</head>
<body>

<h2>SYSTEM BYPASS: EXPERT</h2>

<div id="timer-container">
    <div id="timer-text">TIME REMAINING: 80.00s</div>
    <div id="timer-fill"></div>
</div>

<div id="game-container">
    <div id="source" class="node">PWR</div>
    <div id="grid"></div>
    <div id="output" class="node">CPU</div>
</div>

<div id="status-bar">POWER FLOW: <span id="flow-status" style="color:red">OFFLINE</span></div>


<div id="modal">
    <h1 style="color:#ffb700; text-shadow:0 0 20px #ffb700; text-align:center;">SYSTEM BYPASS<br>COMPLETE</h1>
    <p>Core Access Granted.</p>
    <button class="btn" id="init-core-btn">INITIALIZE CORE</button>
</div>


<div id="fail-modal">
    <h1 style="color:red; font-size:3rem; text-shadow: 0 0 20px red;">SYSTEM FAILURE</h1>
    <p style="color:white; font-size:1.5rem;">CONNECTION SEVERED</p>
</div>

<script>
    const gridSize = 8;
    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('flow-status');
    const outputEl = document.getElementById('output');
    const timerFill = document.getElementById('timer-fill');
    const timerText = document.getElementById('timer-text');
    const failModal = document.getElementById('fail-modal');
    
    
    const tileTypes = {
        'I': { con: [1,0,1,0], svg: 'M25,0 L25,50' },
        'L': { con: [1,1,0,0], svg: 'M25,0 L25,25 L50,25' },
        'T': { con: [0,1,1,1], svg: 'M0,25 L50,25 M25,25 L25,50' },
        'X': { con: [1,1,1,1], svg: 'M25,0 L25,50 M0,25 L50,25' },
        'S': { con: [0,0,0,0], svg: 'M20,20 L30,30 M30,20 L20,30' } 
    };

   
    const levelLayout = [
        ['L', 'S', 'T', 'L', 'I', 'L', 'S', 'T'], // 0
        ['T', 'L', 'L', 'L', 'S', 'I', 'L', 'S'], // 1
        ['T', 'L', 'X', 'X', 'L', 'T', 'S', 'L'], // 2 (START at 2,0)
        ['X', 'L', 'L', 'L', 'T', 'X', 'I', 'L'], // 3
        ['I', 'L', 'X', 'L', 'T', 'X', 'L', 'S'], // 4
        ['L', 'T', 'I', 'L', 'L', 'L', 'L', 'T'], // 5 (EXIT at 5,7)
        ['T', 'I', 'L', 'S', 'I', 'L', 'T', 'I'], // 6
        ['S', 'L', 'T', 'I', 'S', 'L', 'I', 'L']  // 7
    ];

    let gridState = []; 
    let timeLeft = 80;
    let timerInterval = null;
    let gameActive = true;

 
    const _targ = "Z2FtZS5odG1s"; 

    document.getElementById('init-core-btn').addEventListener('click', function() {
        window.location.href = atob(_targ);
    });

    function init() {
        gridEl.innerHTML = "";
        gridState = [];
        
        for(let r=0; r<gridSize; r++) {
            let rowArr = [];
            for(let c=0; c<gridSize; c++) {
                const typeChar = levelLayout[r][c];
                const typeData = tileTypes[typeChar];
                const rot = Math.floor(Math.random() * 4);

                const div = document.createElement('div');
                div.className = 'tile';
                div.innerHTML = `<svg class="pipe" viewBox="0 0 50 50"><path d="${typeData.svg}" /></svg>`;
                div.style.transform = `rotate(${rot * 90}deg)`;
                
                div.onclick = () => rotateTile(r, c);

                gridEl.appendChild(div);
                
                rowArr.push({
                    type: typeChar,
                    baseCon: typeData.con, 
                    rotation: rot,
                    element: div,
                    powered: false
                });
            }
            gridState.push(rowArr);
        }
        
        startTimer();
        checkFlow();
    }

    function startTimer() {
        if(timerInterval) clearInterval(timerInterval);
        timeLeft = 80;
        gameActive = true;
        failModal.style.display = 'none';
        document.body.classList.remove('shaking');
        
        timerInterval = setInterval(() => {
            if(!gameActive) return;
            timeLeft -= 0.1;
            
            let pct = (timeLeft / 80) * 100;
            timerFill.style.width = pct + "%";
            timerText.innerText = "TIME REMAINING: " + timeLeft.toFixed(2) + "s";
            
            if(timeLeft <= 10) {
                timerFill.style.background = "#ff0000"; 
            }

            if(timeLeft <= 0) {
                gameOver();
            }
        }, 100);
    }

    function gameOver() {
        gameActive = false;
        clearInterval(timerInterval);
        timerText.innerText = "CRITICAL FAILURE";
        failModal.style.display = "flex";
        document.body.classList.add('shaking');
        setTimeout(() => { init(); }, 2500);
    }

    function rotateTile(r, c) {
        if(!gameActive) return;
        if(document.getElementById('modal').style.display === 'flex') return;

        const tile = gridState[r][c];
        tile.rotation = (tile.rotation + 1) % 4;
        tile.element.style.transform = `rotate(${tile.rotation * 90}deg)`;
        checkFlow();
    }

    function getConnections(r, c) {
        const tile = gridState[r][c];
        const base = tile.baseCon; 
        const rot = tile.rotation;
        
        let currentCon = [];
        for(let i=0; i<4; i++) {
            currentCon.push(base[(i - rot + 4) % 4]);
        }
        return currentCon; 
    }

    function checkFlow() {
        for(let r=0; r<gridSize; r++) {
            for(let c=0; c<gridSize; c++) {
                gridState[r][c].powered = false;
                gridState[r][c].element.classList.remove('powered');
            }
        }
        outputEl.classList.remove('powered');
        statusEl.textContent = "OFFLINE";
        statusEl.style.color = "red";

        let queue = [];
        
    
        let startCon = getConnections(2, 0);
        if(startCon[3] === 1) { 
            queue.push({r:2, c:0});
            gridState[2][0].powered = true;
            gridState[2][0].element.classList.add('powered');
        }

        let visited = new Set();
        visited.add("2,0");

        let win = false;

        while(queue.length > 0) {
            let curr = queue.shift();
            let r = curr.r;
            let c = curr.c;
            let currCons = getConnections(r, c);

            const dr = [-1, 0, 1, 0];
            const dc = [0, 1, 0, -1];

            for(let i=0; i<4; i++) {
                if(currCons[i] === 1) { 
                    let nr = r + dr[i];
                    let nc = c + dc[i];

                    if(nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                        let neighborCons = getConnections(nr, nc);
                        let requiredEntry = (i + 2) % 4;
                        
                        if(neighborCons[requiredEntry] === 1 && !visited.has(`${nr},${nc}`)) {
                            visited.add(`${nr},${nc}`);
                            gridState[nr][nc].powered = true;
                            gridState[nr][nc].element.classList.add('powered');
                            queue.push({r:nr, c:nc});
                        }
                    } 
                    
                    else if (r === 5 && c === 7 && i === 1) {
                        win = true;
                    }
                }
            }
        }

        if(win) {
            gameActive = false;
            clearInterval(timerInterval);
            outputEl.classList.add('powered');
            statusEl.textContent = "ONLINE";
            statusEl.style.color = "#00ff00";
            setTimeout(() => {
                document.getElementById('modal').style.display = 'flex';
            }, 500);
        }
    }

    init();

</script>
</body>
</html>